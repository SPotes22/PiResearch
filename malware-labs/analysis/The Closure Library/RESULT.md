# Documento de Mejora — Repo-Scanner Heurísticas
# Contexto

Durante el análisis de un proyecto en Crostini, Repo-Scanner marcó como inseguro un script grande, minificado y con texto aparentemente “corrompido”. El código resultó ser un bundle legítimo generado por Google Closure Compiler (con módulos de Chrome Web Store e integradores de pagos).

Este hallazgo muestra que el scanner actual:

Sí es sensible a código autogenerado/no legible.

Pero confunde minificación con cifrado u ofuscación maliciosa.

# Problema identificado

Las heurísticas de detección no diferencian entre:

Ofuscación maliciosa / cifrado real (malware intentando esconderse).

Artefactos de compilación legítimos (Closure, Webpack, Babel, Rollup).

Esto genera falsos positivos y da la impresión de que se detectaron “archivos encriptados de VMs de Google”, cuando en realidad son salidas de build legítimas.

Puntos de mejora en las heurísticas
# 1. Reconocimiento de artefactos comunes de build

Detectar cabeceras/licencias típicas:

Copyright The Closure Library Authors

SPDX-License-Identifier: Apache-2.0

Reconocer patrones de Closure Compiler: funciones goog.provide, goog.require, variables en formato aa, ab, ac, bloques de serialización protobuf.

➡️ Acción: añadir whitelist de frameworks y toolchains conocidos.

# 2. Métrica de “entropía” + contexto

Archivos con alta entropía pueden ser:

Cifrados / comprimidos.

O simplemente minificados.

Mejorar el scanner para que, al detectar entropía alta:

Verifique si existen tokens semánticos conocidos (goog., webpackBootstrap, /*! For license see ... */).

Solo marque como malicioso si NO encuentra esos patrones.

➡️ Acción: añadir verificación semántica antes de marcar como cifrado.

# 3. Identificación de uso de APIs sensibles

No basta con marcar por el uso de chrome.identity o window.postMessage.

Distinguir entre:

Contexto esperado (ej. extensiones, bundles de Google).

Contexto inesperado (ej. script suelto inyectado en /tmp o dentro de un binario no relacionado).

➡️ Acción: incluir contexto de origen del archivo (carpeta de extensión vs. directorio sospechoso).

# 4. Clasificación de “artefactos autogenerados”

Añadir regla: si un archivo tiene >10k líneas minificadas con pocas nuevas líneas, probablemente es un bundle.

Aplicar heurística: “Autogen bundle” → riesgo bajo, pero revisable.

Reportar:

“⚠️ Archivo minificado/autogenerado detectado”

en vez de

“✗ Archivo encriptado sospechoso”.

➡️ Acción: nueva categoría intermedia (no crítico, pero alerta informativa).

5. Pipeline de filtros especializados

Añadir una capa de filtros para stacks específicos (ya tienes Django, Flask, Node, React, REST).

Incluir JavaScript build tools:

Closure

Webpack

Rollup

Babel

Con expresiones regulares que los reconozcan y normalicen reporte.

Beneficios de la mejora

Menos falsos positivos → desarrolladores confían más en el scanner.

Mejor precisión → distingue entre ofuscación legítima y malware.

Mayor transparencia → en vez de “inseguro/encriptado”, se informa “bundle minificado con APIs sensibles”.

# Conclusión

El incidente evidenció la necesidad de ajustar Repo-Scanner para prever y manejar artefactos autogenerados por Closure Compiler y otros toolchains modernos.
No se trata de que el scanner sea capaz de detectar archivos encriptados de Google, sino de que se corrija la heurística para no confundir minificación con cifrado real.
